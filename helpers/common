#!/bin/bash
TEMP_D=""
CR="
"
VERBOSITY=${VERBOSITY:-${CURTIN_VERBOSITY:-0}}

error() { echo "$@" 1>&2; }
debug() {
    [ ${VERBOSITY:-0} -ge "$1" ] || return
    shift
    error "$@"
}

partition_main_usage() {
    cat <<EOF
Usage: ${0##*/} [ options ] target-dev

   partition target-dev with a single partition
   destroy any partition table that might be there already.

   options:
     -f | --format F   use partition table format F. [mbr, gpt, uefi, prep]
                       default mbr
     -E | --end E      end the partition at E (unit 1k bytes)
     -b | --boot       create a boot partition (512 MiB - default)
EOF
    [ $# -eq 0 ] || echo "$@"
}

grub_install_usage() {
    cat <<EOF
Usage: ${0##*/} [ options ] mount-point target-dev

   perform grub-install with mount-point onto target-dev.

   options:
          --uefi       install grub-efi instead of grub-pc
EOF
    [ $# -eq 0 ] || echo "$@"
}

cleanup() {
    if [ -d "$TEMP_D" ]; then
        rm -Rf "$TEMP_D"
    fi
}

wipedev() {
    # wipe the front and end (gpt is at end also)
    local target="$1" size="" out="" bs="" count="" seek="" mb=$((1024*1024))
    local info=""
    getsize "$target" ||
        { error "failed to get size of $target"; return 1; }
    size="$_RET"

    # select a block size that evenly divides size. bigger is generally faster.
    for bs in $mb 4096 1024 512 1; do
        [ "$((size % bs))" = "0" ] && break
    done
    if [ "$bs" = "1" ]; then
        error "WARN: odd sized '$target' ($size). not divisible by 512."
    fi
    [ "$size" -ge "$mb" ] && count=$((mb / bs)) || count=$((size / bs))

    info="size=$size count=$count bs=$bs"
    debug 1 "wiping start of '$target' with ${info}."
    # wipe the first MB (up to 'size')
    out=$(dd if=/dev/zero conv=notrunc "of=$target" \
            "bs=$bs" "count=$count" 2>&1) || {
        error "wiping start of '$target' failed."
        error "  size=$size count=$count bs=$bs: $out"
        return 1
    }

    if [ "$size" -gt "$mb" ]; then
        # do the last 1MB
        count=$((mb / bs))
        seek=$(((size / bs) - $count))
        info="size=$size count=$count bs=$bs seek=$seek"
        debug 1 "wiping end of '$target' with ${info}."
        out=$(dd if=/dev/zero conv=notrunc "of=$target" "seek=$seek" \
            "bs=$bs" "count=$count" 2>&1)
        if [ $? -ne 0 ]; then
            error "wiping end of '$target' failed."
            error "  size=$size count=$count seek=$seek bs=$bs: $out";
            return 1;
        fi
    fi

    if [ -b "$target" ]; then
        blockdev --rereadpt "$target"
        udevadm settle
    fi
}

part2bd() {
    # part2bd given a partition, return the block device it is on
    # and the number the partition is.  ie, 'sda2' -> '/dev/sda 2'
    local dev="$1" fp="" sp="" bd="" ptnum=""
    dev="/dev/${dev#/dev/}"
    fp=$(readlink -f "$dev") || return 1
    sp="/sys/class/block/${fp##*/}"
    [ -f "$sp/partition" ] || { _RET="$fp 0"; return 0; }
    read ptnum < "$sp/partition"
    sp=$(readlink -f "$sp") || return 1
    # sp now has some /sys/devices/pci..../0:2:0:0/block/sda/sda1
    bd=${sp##*/block/}
    bd="${bd%/*}"
    _RET="/dev/$bd $ptnum"
    return 0
}

pt_gpt() {
    local target="$1" end=${2:-""} boot="$3" size="" s512=""
    local start="2048" rootsize="" bootsize="1048576" maxend=""
    local isblk=false
    getsize "$target" ||
        { error "failed to get size of $target"; return 1; }
    size="$_RET"
    if [ -z "$end" ]; then
        end=$(($size/512))
    else
        end=$(($end/512))
    fi

    if [ "$boot" = true ]; then
        maxend=$((($size/512)-$start-$bootsize))
        if [ $maxend -lt 0 ]; then
            error "Disk is not big enough for /boot partition on $target";
            return 1;
        fi
    else
        maxend=$((($size/512)-$start))
    fi
    [ "$end" -gt "$maxend" ] && end="$maxend"
    debug 1 "maxend=$maxend end=$end size=$size"

    [ -b "$target" ] && isblk=true

    if [ "$boot" = true ]; then
        # Creating 'efi', '/boot' and '/' partitions
        sgdisk --new "15:$start:+1M" --typecode=15:ef02 \
            --new "1::+512M" --typecode=1:8300 \
            --new "2::$end" --typecode=2:8300 "$target" ||
            { error "failed to gpt partition $target"; return 1; }
    else
        # Creating 'efi' and '/' partitions
        sgdisk --new "15:$start:+1M" --typecode=15:ef02 \
            --new "1::$end" --typecode=1:8300 "$target" ||
            { error "failed to gpt partition $target"; return 1; }
    fi

    if $isblk; then
        blockdev --rereadpt "$target"
        udevadm settle
        [ -b "${target}1" ] ||
            { error "no partition found ${target}1"; return 1; }
        [ -b "${target}15" ] ||
            { error "no partition found ${target}15"; return 1; }
        if [ "$boot" = true ]; then
            [ -b "${target}2" ] ||
                { error "no partition found ${target}2"; return 1; }
        fi
    fi
}

pt_uefi() {
    local target="$1" end=${2:-""} size="" s512=""
    local start="2048" rootsize="" maxend=""
    local isblk=false
    getsize "$target" ||
        { error "failed to get size of $target"; return 1; }
    size="$_RET"
    if [ -z "$end" ]; then
        end=$(($size/512))
    else
        end=$(($end/512))
    fi

    maxend=$((($size/512)-$start))
    [ "$end" -gt "$maxend" ] && end="$maxend"
    debug 1 "maxend=$maxend end=$end size=$size"

    [ -b "$target" ] && isblk=true

    # Creating 'UEFI' and '/' partitions
    sgdisk --new "15:2048:+512M" --typecode=15:ef00 \
           --new "1::$end" --typecode=1:8300 "$target" ||
        { error "failed to sgdisk for uefi to $target"; return 1; }

    if $isblk; then
        blockdev --rereadpt "$target"
        udevadm settle
        [ -b "${target}1" ] ||
            { error "no partition found ${target}1"; return 1; }
        [ -b "${target}15" ] ||
            { error "no partition found ${target}15"; return 1; }
    fi

    mkfs -t vfat -F 32 -n uefi-boot ${target}15 ||
        { error "failed to partition ${target}15 for UEFI vfat"; return 1; }
}


pt_mbr() {
    local target="$1" end=${2:-""} boot="$3" size="" s512="" ptype="L"
    local start="2048" rootsize="" maxsize="4294967296"
    local maxend="" isblk=false def_bootsize="1048576" bootsize=0
    local isblk=false
    getsize "$target" ||
        { error "failed to get size of $target"; return 1; }
    size="$_RET"

    if $boot; then
        bootsize=$def_bootsize
    fi

    if [ "$(($size/512))" -gt "$maxsize" ]; then
        debug 1 "disk is larger than max for mbr (2TB)"
        s512=$maxsize
    else
        s512=$(($size/512))
    fi
    if [ -n "$end" ]; then
        rootsize=$(((end/512)-start-bootsize))
    else
        rootsize=$((s512-start-bootsize))
    fi

    [ -b "$target" ] && isblk=true

    # interact with sfdisk in units of 512 bytes (--unit S)
    # we start all partitions at 2048 of those (1M)
    local sfdisk_out="" sfdisk_in="" sfdisk_cmd="" t=""
    if "$boot"; then
        t="$start,$bootsize,$ptype,-${CR}"
        t="$t$(($start+$bootsize)),$rootsize,$ptype,*"
        sfdisk_in="$t"
    else
        sfdisk_in="$start,$rootsize,$ptype,*"
    fi
    sfdisk_cmd=( sfdisk --no-reread --force --Linux --unit S "$target" )
    debug 1 "sfdisking with: echo '$sfdisk_in' | ${sfdisk_cmd[*]}"
    sfdisk_out=$(echo "$sfdisk_in" | "${sfdisk_cmd[@]}" 2>&1)
    ret=$?
    [ $ret -eq 0 ] || {
        error "failed to partition $target [${sfdisk_out}]";
        return 1;
    }
    if $isblk; then
        blockdev --rereadpt "$target"
        udevadm settle
        [ -b "${target}1" ] ||
            { error "no partition found ${target}1"; return 1; }
    fi
    out=$(wipefs "--offset=$(($start*512))" "$target" 2>&1) || {
        error "$out";
        error "failed to wipefs first partition of $target";
        return 1;
    }
}

pt_prep() {
    local target="$1" end=${2:-""}
    local cmd="" isblk=false
    [ -b "$target" ] && isblk=true

    sgdisk --zap-all "$target" ||
        { error "failed to clear $target"; return 1; }

    cmd=(
        sgdisk
           --new "1::+8M"  --typecode=1:4100
           --new "2::$end" --typecode=2:8300
           "$target"
    )
    "${cmd[@]}" ||
        fail "Failed to create GPT partitions (${cmd[*]})"

    udevadm trigger
    udevadm settle

    if $isblk; then
        blockdev --rereadpt "$target"
        udevadm settle
        [ -b "${target}1" ] ||
            { error "no partition found ${target}1"; return 1; }
        [ -b "${target}2" ] ||
            { error "no partition found ${target}2"; return 1; }
        dd if=/dev/zero of="${target}1"
    fi

    return 0
}

partition_main() {
    local short_opts="hE:f:bv"
    local long_opts="help,end:,format:,boot,verbose"
    local getopt_out=$(getopt --name "${0##*/}" \
        --options "${short_opts}" --long "${long_opts}" -- "$@") &&
        eval set -- "${getopt_out}" ||
        { partition_main_usage 1>&2; return 1; }

    local cur="" next=""
    local format="mbr" boot=false target="" end=""

    while [ $# -ne 0 ]; do
        cur="$1"; next="$2";
        case "$cur" in
            -h|--help) partition_main_usage ; exit 0;;
            -E|--end) end=$next; shift;;
            -f|--format) format=$next; shift;;
            -b|--boot) boot=true;;
            -v|--verbose) VERBOSITY=$((${VERBOSITY}+1));;
            --) shift; break;;
        esac
        shift;
    done

    [ $# -gt 1 ] && { partition_main_usage "got $# args, expected 1" 1>&2; return 1; }
    [ $# -eq 0 ] && { partition_main_usage "must provide target-dev" 1>&2; return 1; }
    target="$1"
    if [ -n "$end" ]; then
        human2bytes "$end" ||
            { error "failed to convert '$end' to bytes"; return 1; }
        end="$_RET"
    fi

    [ "$format" = "gpt" -o "$format" = "mbr" ] ||
        [ "$format" = "uefi" -o "$format" = "prep" ] ||
        { partition_main_usage "invalid format: $format" 1>&2; return 1; }

    TEMP_D=$(mktemp -d "${TMPDIR:-/tmp}/${0##*/}.XXXXXX") ||
        fail "failed to make tempdir"

    [ -e "$target" ] || { error "$target does not exist"; return 1; }
    [ -f "$target" -o -b "$target" ] ||
        { error "$target not a block device"; return 1; }

    wipedev "$target" ||
        { error "wiping $target failed"; return 1; }

    if [ "$format" = "mbr" ]; then
        pt_mbr "$target" "$end" "$boot"
    elif [ "$format" = "gpt" ]; then
        pt_gpt "$target" "$end" "$boot"
    elif [ "$format" = "uefi" ]; then
        pt_uefi "$target" "$end"
    elif [ "$format" = "prep" ]; then
        pt_prep "$target" "$end"
    fi

    trap cleanup EXIT

    return 0
}

human2bytes() {
    # converts size suitable for input to resize2fs to bytes
    # s:512 byte sectors, K:kilobytes, M:megabytes, G:gigabytes
    # none: block size of the image
    local input=${1} defunit=${2:-1024}
    local unit count;
    case "$input" in
        *s) count=${input%s}; unit=512;;
        *K) count=${input%K}; unit=1024;;
        *M) count=${input%M}; unit=$((1024*1024));;
        *G) count=${input%G}; unit=$((1024*1024*1024));;
        *)  count=${input}  ; unit=${defunit};;
    esac
   _RET=$((${count}*${unit}))
}

getsize() {
    # return size of target in bytes
    local target="$1"
    if [ -b "$target" ]; then
        _RET=$(blockdev --getsize64 "$target")
    elif [ -f "$target" ]; then
        _RET=$(stat "--format=%s" "$target")
    else
        return 1;
    fi
}

is_md() {
    case "${1##*/}" in
        md[0-9]) return 0;;
    esac
    return 1
}

install_grub() {
    local long_opts="uefi"
    local getopt_out="" mp_efi=""
    getopt_out=$(getopt --name "${0##*/}" \
        --options "" --long "${long_opts}" -- "$@") &&
        eval set -- "${getopt_out}"

    local uefi=0

    while [ $# -ne 0 ]; do
        cur="$1"; next="$2";
        case "$cur" in
            --uefi) uefi=$((${uefi}+1));;
            --) shift; break;;
        esac
        shift;
    done

    [ $# -lt 2 ] && { grub_install_usage "must provide mount-point and target-dev" 1>&2; return 1; }

    local mp="$1"
    local cmdline tmp r=""
    shift
    local grubdevs
    grubdevs=( "$@" )
    if [ "${#grubdevs[@]}" = "1" -a "${grubdevs[0]}" = "none" ]; then
        grubdevs=( )
    fi

    # find the mp device
    mp_dev=$(awk -v MP=${mp} '$2==MP {print$1}' /proc/mounts) || {
        error "unable to determine device for mount $mp";
        return 1;
    }
    [ -b "$mp_dev" ] || { error "$mp_dev is not a block device!"; return 1; }

    # get dpkg arch
    local dpkg_arch=""
    dpkg_arch=$(chroot "$mp" dpkg --print-architecture)
    r=$?
    [ $r -eq 0 ] || {
        error "failed to get dpkg architecture [$r]"
        return 1;
    }

    # set correct grub package
    local grub_name="grub-pc"
    local grub_target="i386-pc"
    if [ "${dpkg_arch#ppc64}" != "${dpkg_arch}" ]; then
        grub_name="grub-ieee1275"
        grub_target="powerpc-ieee1275"
    elif [ "$uefi" -ge 1 ]; then
        grub_name="grub-efi-$dpkg_arch"
        if [ "$dpkg_arch" = "amd64" ]; then
            grub_target="x86_64-efi"
        fi
    fi

    # check that the grub package is installed
    tmp=$(chroot "$mp" dpkg-query --show \
        --showformat='${Status}\n' $grub_name)
    r=$?
    if [ $r -ne 0 -a $r -ne 1 ]; then
        error "failed to check if $grub_name installed";
        return 1;
    fi
    case "$tmp" in
        install\ ok\ installed) :;;
        *) debug 1 "$grub_name not installed, not doing anything";
            return 0;;
    esac

    # check that mount point has efi partition, and that its mounted
    # at /boot/efi and added to the fstab
    if [ "$uefi" -ge 1 ]; then
        # this assumes that the device was '/dev/xxx[0-9]' and the efi is 15.
        local efi_dev="${mp_dev%[0-9]}15"
        [ -b ${efi_dev} ] || { error "no UEFI partition on ${efi_dev}"; return 1; }

        fslabel=$(blkid -s LABEL -o value "${efi_dev}")
        fstype=$(blkid -s TYPE -o value "${efi_dev}")
        [ "$fstype" = "vfat" ] || { error "${efi_dev} is not a vfat fs"; return 1; }
        [ -n "$fslabel" ] || {  error "no label on EFI device"; return 1; }

        mp_efi=$(lsblk --nodeps -n --out "MOUNTPOINT" ${efi_dev})
        [ -z "$mp_efi" ] || umount "$mp_efi"

        if [ ! -e "$mp/boot/efi" ]; then
            mkdir -p "$mp/boot/efi" || { error "failed to mount EFI partition"; return 1; }
            mount "$efi_dev" "$mp/boot/efi" || { error "unable to mount efi part"; return 1; }
            mp_efi="$mp/boot/efi"
        fi

        echo "LABEL=${fslabel}  /boot/efi   vfat    defaults    0 0" >> "$mp/etc/fstab"
    fi

    # copy anything after '--' on cmdline to install'd cmdline
    read cmdline < /proc/cmdline
    local newargs=""

    tmp="${cmdline##* -- }"
    if [ "$tmp" != "$cmdline" ]; then
        # there was an explicit '--', so copy stuff some after it
        newargs=$(set -f;
            c="";
            for p in ${cmdline##* -- }; do
                case "$p" in
                    (BOOTIF=*|initrd=*|BOOT_IMAGE=*) continue;;
                esac
                c="$c $p";
            done
            echo "${c# }"
        )
    elif [ "${cmdline#* console=}" != "${cmdline}" ]; then
        # there are 'console=' params, copy those.
        newargs=$(set -f; c=""; for p in $cmdline; do
            [ "${p#console}" = "$p" ] || c="$c $p"; done; echo "${c# }")
    fi

    local grub_d="etc/default/grub.d"
    local mygrub_cfg="$grub_d/50-curtin-settings.cfg"
    [ -d "$mp/$grub_d" ] || mkdir -p "$mp/$grub_d" ||
        { error "Failed to create $grub_d"; return 1; }

    # LP: #1179940 . The 50-cloudig-settings.cfg file is written by the cloud
    # images build and defines/override some settings. Disable it.
    local cicfg="$grub_d/50-cloudimg-settings.cfg"
    if [ -f "$mp/$cicfg" ]; then
       debug 1 "moved $cicfg out of the way"
       mv "$mp/$cicfg" "$mp/$cicfg.disabled"
    fi

    : > "$mp/$mygrub_cfg" ||
        { error "Failed to write '$mygrub_cfg'"; return 1; }
    {
        [ "${REPLACE_GRUB_LINUX_DEFAULT:-1}" = "0" ] ||
            echo "GRUB_CMDLINE_LINUX_DEFAULT=\"$newargs\""
        echo "# disable grub os prober that might find other OS installs."
        echo "GRUB_DISABLE_OS_PROBER=true"
    } >> "$mp/$mygrub_cfg"

    local short="" bd="" grubdev grubdevs_new=""
    grubdevs_new=()
    for grubdev in "${grubdevs[@]}"; do
        if is_md "$grubdev"; then
            short=${grubdev##*/}
            for bd in "/sys/block/$short/slaves/"/*; do
                [ -d "$bd" ] || continue
                bd=${bd##*/}
                bd="/dev/${bd%[0-9]}" # FIXME: part2bd
                grubdevs_new[${#grubdevs_new[@]}]="$bd"
            done
        else
            grubdevs_new[${#grubdevs_new[@]}]="$grubdev"
        fi
    done
    grubdevs=( "${grubdevs_new[@]}" )

    if [ "$uefi" -ge 1 ]; then
        debug 1 "installing ${grub_name} to: /boot/efi"
        chroot "$mp" env DEBIAN_FRONTEND=noninteractive sh -ec '
            dpkg-reconfigure "$1"
            update-grub
            grub-install --target=$2 --efi-directory=/boot/efi \
                --bootloader-id=ubuntu --recheck' -- \
            "${grub_name}" "${grub_target}" </dev/null ||
            { error "failed to install grub!"; return 1; }
    else
        debug 1 "installing ${grub_name} to: ${grubdevs[*]}"
        chroot "$mp" env DEBIAN_FRONTEND=noninteractive sh -ec '
            pkg=$1; shift;
            dpkg-reconfigure "$pkg"
            update-grub
            for d in "$@"; do grub-install "$d" || exit; done' \
            -- "${grub_name}" "${grubdevs[@]}" </dev/null ||
            { error "failed to install grub!"; return 1; }
    fi

    if [ -n "${mp_efi}" ]; then
        umount "$mp_efi" ||
            { error "failed to unmount $mp_efi"; return 1; }
    fi

    return
}

# vi: ts=4 expandtab syntax=sh
