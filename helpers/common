#!/bin/bash
TEMP_D=""

error() { echo "$@" 1>&1; }
debug() { [ ${VERBOSITY:-0} -lt "$1" ] || error "$@"; }

partition_main_usage() {
	cat <<EOF
Usage: ${0##*/} [ options ] target-dev

   partition target-dev with a single partition
   destroy any partition table that might be there already.

   options:
     -f | --format F   use partition table format F. [mbr, gpt]
                       default gpt
     -E | --end E      end the partition at E (unit 1k bytes)
EOF
    [ $# -eq 0 ] || echo "$@"
}

cleanup() {
    if [ -d "$TEMP_D" ]; then
        rm -Rf "$TEMP_D"
    fi
}

wipedev() {
	# wipe the front and end (gpt is at end also)
	local target="$1" size="" out=""
	getsize "$target" ||
		{ error "failed to get size of $target"; return 1; }
	size="$_RET"
	
	dd if=/dev/zero conv=notrunc of="$target" \
		bs=$((1024*1024)) count=1 >/dev/null 2>&1 ||
		{ error "failed to zero beginning of $target"; return 1; }

	out=$(dd if=/dev/zero conv=notrunc of="$target" bs=1024 \
		seek=$(((size/1024)-1024)) count=1024 2>&1)
	[ $? -eq 0 ] ||
		{ error "failed to wipe end of $target [$size]: $out"; return 1; }

    if [ -b "$target" ]; then
	    blockdev --rereadpt "$target"
	    udevadm settle
    fi
}

pt_gpt() {
    local target="$1" end=${2:-""} size="" s512="" ptype="L"
    local start="2048" pt1size="" maxend=""
    local isblk=false
    getsize "$target" ||
        { error "failed to get size of $target"; return 1; }
    size="$_RET"
    if [ -z "$end" ]; then
        end=$(($size/512))
    else
        end=$(($end/512))
    fi
    maxend=$((($size/512)-2048))
    [ "$end" -gt "$maxend" ] && end="$maxend"
    debug 1 "maxend=$maxend end=$end size=$size"

    sgdisk --new "15:2048:+1M" --typecode=15:ef02 \
           --new "1::$end"     --typecode=1:8300 "$target"
}


pt_mbr() {
	local target="$1" end=${2:-""} size="" s512="" ptype="L"
	local start="2048" pt1size="" maxsize="4294967296"
	local isblk=false
	getsize "$target" ||
		{ error "failed to get size of $target"; return 1; }
	size="$_RET"

	if [ "$(($size/512))" -gt "$maxsize" ]; then
		debug 1 "disk is larger than max for mbr (2TB)"
		s512=$maxsize
	else
		s512=$(($size/512))
	fi
	if [ -n "$end" ]; then
		pt1size=$(((end/512)-2048))
	else
		pt1size=$((s512-2048))
	fi

	[ -b "$target" ] && isblk=true

	# interact with sfdisk in units of 512 bytes (--unit S)
	# we start all partitions at 2048 of those (1M)
	local sfdisk_out="" sfdisk_in="2048,$pt1size,$ptype,*" sfdisk_cmd=""
	sfdisk_cmd=( sfdisk --no-reread --force --Linux --unit S "$target" )
	debug 1 "sfdisking with: echo '$sfdisk_in' | ${sfdisk_cmd[*]}"
	sfdisk_out=$(echo "$sfdisk_in" | "${sfdisk_cmd[@]}" 2>&1)
	ret=$?
	[ $ret -eq 0 ] || {
		error "failed to partition $target [${sfdisk_out}]";
		return 1;
	}
	if $isblk; then
		blockdev --rereadpt "$target"
		udevadm settle
		[ -b "${target}1" ] ||
			{ error "no partition found ${target}1"; return 1; }
	fi
	out=$(wipefs "--offset=$(($start*512))" "$target" 2>&1) || {
		error "$out";
		error "failed to wipefs first partition of $target";
		return 1;
	}
}

partition_main() {
	local short_opts="hE:f:v"
	local long_opts="help,end:,format:,verbose"
	local getopt_out=$(getopt --name "${0##*/}" \
		--options "${short_opts}" --long "${long_opts}" -- "$@") &&
		eval set -- "${getopt_out}" ||
		{ partition_usage 1>&2; return 1; }

	local cur="" next=""
	local format="mbr" target="" end=""

	while [ $# -ne 0 ]; do
		cur="$1"; next="$2";
		case "$cur" in
			-h|--help) partition_usage ; exit 0;;
			-f|--format) format=$next; shift;;
			-E|--end) end=$next; shift;;
			-v|--verbose) VERBOSITY=$((${VERBOSITY}+1));;
			--) shift; break;;
		esac
		shift;
	done

	[ $# -gt 1 ] && { partition_usage "got $# args, expected 1" 1>&2; return 1; }
	[ $# -eq 0 ] && { partition_usage "must provide target-dev" 1>&2; return 1; }
	target="$1"
	if [ -n "$end" ]; then
		human2bytes "$end" ||
			{ error "failed to convert '$end' to bytes"; return 1; }
		end="$_RET"
	fi

	[ "$format" = "gpt" -o "$format" = "mbr" ] ||
		{ partition_usage "invalid format: $format" 1>&2; return 1; }

	TEMP_D=$(mktemp -d "${TMPDIR:-/tmp}/${0##*/}.XXXXXX") ||
		fail "failed to make tempdir"

	[ -e "$target" ] || { error "$target does not exist"; return 1; }
	[ -f "$target" -o -b "$target" ] ||
		{ error "$target not a block device"; return 1; }

	wipedev "$target" ||
		{ error "wiping $target failed"; return 1; }

	if [ "$format" = "mbr" ]; then
		pt_mbr "$target" "$end"
	elif [ "$format" = "gpt" ]; then
		pt_gpt "$target" "$end"
	fi

	trap cleanup EXIT

	return 0
}

human2bytes() {
	# converts size suitable for input to resize2fs to bytes
	# s:512 byte sectors, K:kilobytes, M:megabytes, G:gigabytes
	# none: block size of the image
	local input=${1} defunit=${2:-1024}
	local unit count;
	case "$input" in
		*s) count=${input%s}; unit=512;;
		*K) count=${input%K}; unit=1024;;
		*M) count=${input%M}; unit=$((1024*1024));;
		*G) count=${input%G}; unit=$((1024*1024*1024));;
		*)  count=${input}  ; unit=${defunit};;
	esac
   _RET=$((${count}*${unit}))
}

getsize() {
	local target="$1"
	if [ -b "$target" ]; then
		_RET=$(blockdev --getsize64 "$target")
	elif [ -f "$target" ]; then
		_RET=$(stat "--format=%s" "$target")
	else
		return 1;
	fi
}

is_md() {
    case "${1##*/}" in
        md[0-9]) return 0;;
    esac
    return 1
}

install_grub() {
    local mp="$1"
    local cmdline tmp r=""
    shift
    local grubdevs
    grubdevs=( "$@" )
    
    tmp=$(chroot "$mp" dpkg-query --show \
        --showformat='${Status}\n' grub-pc)
    r=$?
    if [ $r -ne 0 -a $r -ne 1 ]; then
        error "failed to check if grub-pc installed";
        return 1;
    fi
    case "$tmp" in
        install\ ok\ installed) :;;
        *) debug 1 "grub-pc not installed, not doing anything";
            return 0;;
    esac

    # copy anything after '--' on cmdline to install'd cmdline
    read cmdline < /proc/cmdline
    local reconf="" newargs=""

    tmp="${cmdline##* -- }"
    if [ "$tmp" != "$cmdline" ]; then
        # there was an explicit '--', so copy stuff some after it
        newargs=$(set -f;
            c="";
            for p in ${cmdline##* -- }; do
                case "$p" in
                    (BOOTIF=*|initrd=*|BOOT_IMAGE=*) continue;;
                esac
                c="$c $p";
            done
            echo "${c# }"
        )
    elif [ "${cmdline#* console=}" != "${cmdline}" ]; then
        # there are 'console=' params, copy those.
        newargs=$(set -f; c=""; for p in $cmdline; do
            [ "${p#console}" = "$p" ] || c="$c $p"; done; echo "${c# }")
    fi

    if [ "${REPLACE_GRUB_LINUX_DEFAULT:-1}" != "0" ]; then
        local n="GRUB_CMDLINE_LINUX_DEFAULT"
        local sede="s|$n=.*|$n=\"$newargs\"|"
        sed -i "$sede" "$mp/etc/default/grub" ||
            { error "failed to update /etc/default/grub"; return 1; }
        grep "$n" "$mp/etc/default/grub"
        reconf="dpkg-reconfigure grub-pc"
        debug 1 "updating cmdline to '${newargs}'"

        # LP: #1179940 . this fix was applied to raring, which
        # made changes above not stick.  This might not be the best
        # way to handle this, but we'll do it for now.
        local cicfg="etc/default/grub.d/50-cloudimg-settings.cfg"
        if [ -f "$mp/$cicfg" ]; then
            debug 1 "moved $cicfg out of the way"
            mv "$mp/$cicfg" "$mp/$cicfg.disabled"
        fi
    fi

    local short="" bd="" grubdev grubdevs_new=""
    grubdevs_new=()
    for grubdev in "${grubdevs[@]}"; do
        if is_md "$grubdev"; then
            short=${grubdev##*/}
            for bd in "/sys/block/$short/slaves/"/*; do
                [ -d "$bd" ] || continue
                bd=${bd##*/}
                bd="/dev/${bd%[0-9]}" # hack: part2bd
                grubdevs_new[${#grubdevs_new[@]}]="$bd"
            done
        else
            grubdevs_new[${#grubdevs_new[@]}]="$grubdev"
        fi
    done
    grubdevs=( "${grubdevs_new[@]}" )

    debug 1 "installing grub to: ${grubdevs[*]}"
    chroot "$mp" env DEBIAN_FRONTEND=noninteractive sh -ec '
        prober="/etc/grub.d/30_os-prober"
        [ -x $prober ] && chmod -x "$prober"
        dpkg-reconfigure grub-pc
        [ -f $prober ] && chmod +x "$prober"
        for d in "$@"; do grub-install "$d" || exit; done' \
        -- "${grubdevs[@]}" </dev/null ||
        { error "failed to install grub!"; return 1; }
}

# vi: ts=4 expandtab syntax=sh
